{"name":"Shovejs","body":"<html>\r\n<head>\r\n\t<style>\r\n\tbody {\r\n\tfont-family: \"HelveticaNeue-Light\", \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif;\r\n\tfont-size: 16px;\r\n\tcolor: #4f4f4f;\r\n}\r\n\t</style>\r\n</head>\r\n\r\n\r\n<body>\r\n<h6>version 0.1</h6>\r\n<h1>ShoveJS</h1>\r\n\r\n\r\n<p>...is a JavaScript microframework (lightly) inspired by RobotLegs (ActionScript 3) and its default dependency injection library SwiftSuspenders. It's meant to provide implementations of common patterns needed while developing web apps. If you don't <em>like</em> a specific piece, you should be able to swap it out with another implementation, and if you don't <em>need</em> a piece, you should be able to omit it.</p>\r\n\r\n<p>The overall goal is to make bootstrapping a modular application a little more sane. ShoveJS encourages modularity, flexibility, and loose-coupling.</p>\r\n\r\n<p>A few of the provided features:\r\n<ul>\r\n\t<li>Dependency Injection</li>\r\n\t<li>Automatic view creation / mediation</li>\r\n\t<li>Service Initialization</li>\r\n\t<li>Serialization / Deserialization (JSON) of complex types (maintaining class/prototype)</li>\r\n</ul>\r\n</p>\r\n\r\n<p>It currently depends on the following 3rd party libraries:\r\n<ul>\r\n\t<li>requirejs</li>\r\n\t<li>js signals</li>\r\n\t<li>Q - Promises - required for (de)serialization)</li>\r\n\t<li>json2 - required for (de)serialization support in older browsers</li>\r\n</ul>\r\n</p>\r\n\r\n<p>\r\nSome examples require additional 3rd party libraries, but they're not otherwise required:\r\n<ul>\r\n\t<li>jQuery</li>\r\n</ul>\r\n</p>\r\n\r\n<h1>Application Bootstrapping</h1>\r\n<p>An application's HTML typically includes requirejs and creates a new instance of Main in the callback (which is passed an HTMLElement to serve as the root view).</p>\r\n\r\n<p>\r\nThe application main will then:\r\n<ul>\r\n\t<li>include a basket of classes (via requirejs)</li>\r\n\t<li>register the Model classes</li>\r\n\t<li>register View classes for Model classes</li>\r\n\t<li>register Meditor classes for View classes</li>\r\n\t<li>register Factory classes for Model classes</li>\r\n\t<li>register Service classes</li>\r\n\t<li>map Application signals to CommandClasses</li>\r\n\t<li>Context View???</li>\r\n\t<li>Get view(s) for the application context and append(s) them to the root view.</li>\r\n</ul>\r\n</p>\r\n\r\n\r\n<h1>Dependency Injection</h1>\r\n\r\n<h2>Defining Injectable Fields for a Class</h2>\r\n<p>Each class that will have properties injected, defines....</p>\r\n\r\n<pre>\r\n\tSomeClass.injectableFields = {fieldName:FieldClass, fieldName2:FieldClass};\r\n</pre>\r\n\r\n<p>\r\nIn most cases, your classes will have their injectable fields mapped automatically. This is the case for:\r\n<ul>\r\n\t<li>view classes</li> \r\n\t<li>mediator classes</li>\r\n\t<li>command classes</li>\r\n</ul>\r\n</p>\r\n\r\n<p>\r\nManually register a class to have its injectable fields mapped:\r\n<pre>\r\n\tcontext.injector.mapInjectionFields(SomeClass);\r\n</pre>\r\n</p>\r\n\r\n<h2>Defining Injection Values</h2>\r\n<p>\r\nValues are mapped to injectable fields:\r\n</p>\r\n<pre>\r\n\tcontext.injector.mapValue = (SomeClass, \"injectionField\", injectionValue)\r\n</pre>\r\n\r\n\r\n<p>The injectionValue will be mapped to any injectable field of type SomeClass matching \"injectionField\".</p>\r\n\r\n<strong>NOTE:</strong> the type of class being injected into does not matter. More on child Injectors later.\r\n\r\n\r\n<h2>Injection Life-cycle</h2>\r\n<p>The above set-up must be in place first. Afterwards:</p>\r\n<pre>\r\n\tcontext.injector.injectInto(someInstance);\r\n</pre>\r\n\r\n\r\n\r\n<h1>Serialization / Deserialization</h1>\r\n\r\n<h2>Register Model Class</h2>\r\n<p>ShoveJS makes no assumptions about your model classes. It should not be necessary to store unique ids, (de)serialization logic, etc in your models. ShoveJS promotes a model containing nothing but data and (eg update) signals.</p>\r\n\r\n<p>Any model (and the models it uses via composition) need to be registered in the class registry:\r\n<pre>\r\n\tcontext.registerClass(SomeModelClass);\r\n</pre>\r\n</p>\r\n\r\n<p>This feature relies on a ClassRegistry which maps Classes to an id. The proviced ClassRegistry implementation will call toString as a static method of the registering Class if an id is not provided.</p>\r\n\r\n<p>\r\nFor example:\r\n<pre>\r\n\tcontext.registerClass(SomeClass.toString(), SomeClass);\r\n</pre>\r\nwould be equivalent to:\r\n<pre>\r\n\tcontext.registerClass(SomeClass);\r\n</pre>\r\n</p>\r\n\r\n<h2>Register Model Factories</h2>\r\n<pre>\r\n\tvar someModelFactoryInstance = new SomeModelFactory();\r\n\tcontext.factoryRegistry.set(SomeModel, someModelFactoryInstance);\r\n</pre>\r\n\r\n<h2>Factory Interface</h2>\r\n\r\n<ul>\r\n\t<li>Factory.toString() -- returns a unique id for this Factory class</li>\r\n\t<li>Factory.toJSON() -- returns a JSON-ready serialization object</li>\r\n\t<li>Factory.fromJSON -- returns an object with fully classed and cross-referenced objects</li>\r\n</ul>\r\n\r\n<h2>Factory Patterns</h2>\r\n<h3>toJSON</h3>\r\n<p>\r\nThe Factory is passed the instance to be serialized:\r\n<pre>\r\n\tDictionaryFactory.prototype.toJSON = function (dictionary) { /* */ };\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nA typical toJSON implementation starts by creating an empty object:\r\n<pre>\r\n\tvar jsonObj = {};\r\n</pre>\r\n</p>\r\n\r\n<p>Fields containing only Numbers &amp; Strings (or Arrays/Objects containing only Numbers, Strings, Arrays, and Objects) can be serialized directly:\r\n<pre>\r\n\tjsonObj.field = model.field;\r\n</pre>\r\n</p>\r\n\r\n<p>The JSONService exposes a method toJSONref which can be utilized by factory.toJSON methods to convert composed objects into \"JSON references\" pointing to registered Objects. Objects / values for which no entry is found are returned unchanged. //????\r\n</p>\r\n\r\n<p>\r\nFor example, the DictionaryFactory:\r\n<pre>\r\n\tjsonObj.keys = [];\r\n\tfor (var i=0, len=dictionary.keys.length; i&lt;len; i++)\r\n\t{\r\n\t\tjsonObj.keys.push( this.jsonService.toJSONref(dictionary.keys[i]) );\r\n\t}\r\n</pre>\t\r\n</p>\r\n\r\n<p>A new keys field is created on the Dictionary's JSON object. For each key, a value is placed in that Array containing a special object described in the JSON Format section below.</p>\r\n\r\n<h3>fromJSON</h3>\r\n\r\n<p>\r\nA factory is passed the jsonObject to be de-serialized:\r\n<pre>\r\n\tDictionaryFactory.prototype.toJSON = function (dictionary) { /* */ };\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nThe typical fromJSON implementation starts by creating an empty model:\r\n<pre>\r\n\tvar dictionary = new Dictionary();\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nFields containing only Numbers &amp; Strings (or Arrays/Objects containing only Numbers, Strings, Arrays, and Objects) can be deserialized directly:\r\n<pre>\r\n\tmodel.field = jsonObj.field;\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nJSONService uses the Q library's Promise implementation to provide instance references:\r\n<pre>\r\n\tjsonObj.referencedObject.promise.then( function (referencedObject) {model.referencedObject = referencedObject;} );\r\n</pre>\r\n</p>\r\n\r\n<p>\t\r\nIf your model needs to do some processing once the value is available use a setter function:\r\n<pre>\r\n\tjsonObj.normalizedPoint.promise.then ( function (point) {model.setNormalizedPoint(point); } );\r\n</pre>\t\r\n</p>\r\n\r\n<p>\r\nWriting deserialization promise logic is by far the trickiest part of using the framework. (It's worth it!) The included Factory classes contain several patterns worth using as starting points.\r\n</p>\r\n\r\n<h2>JSON Format</h2>\r\n<p>\r\nThe JSON returned from toJSON will always contain two fields:\r\n<ul>\r\n\t<li>meta</li>\r\n\t<li>data</li>\r\n</ul>\r\nor:\r\n<pre>\r\n\t{\r\n\t\t\"meta\":{ /* */ },\r\n\t\t\"data\":{ /* */ }\r\n\t}\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nThe meta field contains a hash of object references:\r\n\t<pre>\r\n\t\"meta\":\r\n\t{\r\n\t  \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:0\": {},\r\n\t  \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:1\": {}\r\n\t}\r\n\t</pre>\r\n\t</p>\r\n\r\n\t<p>\r\n\tEach of the values contains two fields:\r\n\t<ul>\r\n\t\t<li>type</li>\r\n\t\t<li>value</li>\r\n\t</ul>\r\n\t</p>\r\n\r\n\t<p>\r\n\tIf any property within value's tree is itself a registered object, it will be converted to a JSON reference of the form:\r\n\t<pre>{\"$ref\": \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:1\"}:</pre>\r\n\t</p>\r\n\r\n\t<p>\r\n\tThe same reference objects are used in the data branch of the object tree. When sending the JSON string to the server the resulting JSON might look like:\r\n\t<pre>\r\n\t{\"meta\" :{\r\n\t  \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:0\": {\r\n\t    \"type\": \"[Some Class]\",\r\n\t    \"value\": {\r\n\t      \"field1\": [\r\n\t        {\r\n\t          \"$ref\": \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:1\"\r\n\t        }\r\n\t      ]\r\n\t    }\r\n\t  },\r\n\t  \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:1\": {\r\n\t    \"type\": \"[Some Class]\",\r\n\t    \"value\": {\r\n\t      \"field1\": [\r\n\t        {\r\n\t          \"$ref\": \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:0\"\r\n\t        }\r\n\t      ],\r\n\t      \"field2\": {\r\n\t        \"$ref\": \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:7\"\r\n\t      }\r\n\t    }\r\n\t  },\r\n\t  \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:7\": {\r\n\t    \"type\": \"[Dictionary Class]\",\r\n\t    \"value\": {\r\n\t      \"keys\": [\r\n\t        {\r\n\t          \"$ref\": \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:11\"\r\n\t        }\r\n\t      ],\r\n\t      \"values\": [\r\n\t        {\r\n\t          \"$ref\": \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:12\"\r\n\t        }\r\n\t      ]\r\n\t    }\r\n\t  },\r\n\t  \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:11\": {\r\n\t    \"type\": \"[Data1 Class]\",\r\n\t    \"value\": 123\r\n\t  },\r\n\t  \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:12\": {\r\n\t    \"type\": \"[Data2 Class]\",\r\n\t    \"value\": \"xxx\"\r\n\t  }\r\n\t}, \"data\" :{\r\n\t  \"a\": {\r\n\t    \"$ref\": \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:0\"\r\n\t  },\r\n\t  \"a\": {\r\n\t    \"$ref\": \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:1\"\r\n\t  },\r\n\t  \"c\": {\r\n\t    \"$ref\": \"bfb37975-148e-5f87-6f12-f4a15dbf3b34:2\"\r\n\t  }\r\n\t}} \r\n</pre>\r\n</p>\r\n\r\n<p>\r\nWhen deserializing, the returned object will match the structure defined in the data field.\r\n</p>\r\n\r\n\r\n<h3>About the ObjectRegistry</h3>\r\n<p>\r\nAn ObjectRegistry maps a unique object id to an instance. Usually, this is handled for automatically.\r\n</p>\r\n\r\n<p>\r\nManually:\r\n<pre>\r\n\tobjectRegistry.registerModel(id, instance);\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nThe JSONService has dependencies mapped for injection:\r\n<ul>\r\n\t<li>context: Context - provides access to class &amp; factory mappings</li>\r\n\t<li>classRegistry: ClassRegistry - maps unique class ids to classes</li>\r\n\t<li>objectRegistry: ObjectRegistry - maps unique ids to instances</li>\r\n\t<li>objectIdentityService: ObjectIdentityService - unique id generator</li>\r\n</ul>\r\n</p>\r\n\r\n<p>\r\nThese are mapped for you. \r\n</p>\r\n\r\n<p>\r\nThe JSONService handles calling factory.toJSON and factory.fromJSON for each object type referenced while walking data objects and json objects respectively &amp; recursively.\r\n</p>\r\n\r\n\r\n\r\n\r\n<h1>Automatic View Creation / Mediation</h1>\r\n\r\n<h2>Register Model Classes</h2>\r\n<p>\r\n\t(See above)\r\n</p>\r\n\r\n<h2>Map Model Classes to View Classes</h2>\r\n<p>\r\n<pre>\r\n\tcontext.mapModelView(Controls,\t\tControlsView);\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nan additional parameter allows multiple views per model class\r\n<pre>\r\n\tcontext.mapModelView(Controls,\t\tControlsView,\t'map');\r\n</pre>\r\n</p>\r\n\r\n<h2>Register View Factory Classes</h2>\r\n<p>\r\n(See above)\r\n<pre>\r\n\tcontext.mapViewMediator(ControlsView,\t\tControlsCommandMap);\r\n</pre>\r\n</p>\r\n\r\n<h2>Mediator Classes</h2>\r\n<p>\r\nMediator instances are automatically created and  linked to views when views are created. They're responsible for linking UI-events to Command classes. Signals published by the View class are automatically mapped to the Mediator's injection fields of the same name.\r\n</p>\r\n\r\n<pre>\r\n\tControlsCommandMap.injectionFields = {\r\n\t\tcontext:Context, \r\n\t\tloadRequested:signals.Signal,\r\n\t\tsaveRequested:signals.Signal\r\n\t};\r\n</pre>\r\n\r\n<h2>View Classes</h2>\r\n\r\n<p>\r\nViews have:\r\n<ul>\r\n\t<li>an \"on\" field containing named UI signals to publish for automatic mediation</li> \r\n\t<li>an observe method which will be passed the model instance to view (READ ONLY!)</li>\r\n</ul>\r\n</p>\r\n\r\n<p>\r\nThe Mediator's map/unmap methods link/unlink these signals to Command classes.\r\n</p>\r\n\r\n<pre>\r\n\tControlsCommandMap.prototype.map = function () {\r\n\t\tthis.context.mapSignal(this.loadRequested,\tLoadNewFeatureDataCommand,\tthis);\r\n\t\tthis.context.mapSignal(this.saveRequested,\tSaveZoneDataCommand,\t \tthis);\r\n\t}\r\n\r\n\tControlsCommandMap.prototype.unmap = function () {\r\n\t\tthis.context.unmapSignal(this.loadRequested,\tLoadNewFeatureDataCommand,\tthis);\r\n\t\tthis.context.unmapSignal(this.saveRequested,\tSaveZoneDataCommand,\t\tthis);\r\n\t}\r\n</pre>\r\n\r\n\r\n<h2>Command Interface</h2>\r\n<p>\r\nCommands:\r\n<ul>\r\n\t<li>have an execute method</li>\r\n\t<li>have their injection fields automatically populated by</li>\r\n\t\t<ul>\r\n\t\t\t<li>UI signal data payload</li>\r\n\t\t\t<li>The view's controllerData (context.registerView) -- typically, this contains the model the view is observing</li>\r\n\t\t</ul>\r\n</ul>\r\n</p>\r\n\r\n\r\n<h2>Creating / Getting a View</h2>\r\n\r\n<pre>\r\n\tvar controlsView = context.getViewByModel(controls);\r\n\tvar controllerData = {controls:controls};\r\n\tcontext.registerView(controlsView, controllerData);\r\n</pre>\r\n\r\n<p>\r\nIf you're using the multi-views per model class case above:\r\n<pre>\r\n\tvar controlsView = context.getViewByModel(controls, 'map');\r\n</pre>\r\n</p>\r\n\r\n\r\n\r\n<h1>Service Initialization</h1>\r\n<h2>Service Interface</h2>\r\n\r\n<p>\r\nServices have:\r\n<ul>\r\n\t<li>an id to register themselves</li>\r\n\t<li>an optional init method</li>\r\n</ul>\r\n</p>\r\n\r\n<h2>Service Life-cycle</h2>\r\n<p>\r\nWhen you register a service, the following things happen:\r\n</p>\r\n\r\n<p>\r\nThe service's injectable fields are mapped:\r\n<pre>\r\n\tcontext.injector.mapInjectionFields(SomeService);\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nThe service is registered under its id &amp; class:\r\n<pre>\r\n\tvar someService = new SomeService(); // simplified here\r\n\tcontext.injector.mapValue(SomeService, 'someService', someService);\r\n</pre>\r\n</p>\r\n\r\n<p>\r\nWhen the context is initialized:\r\n\t<ul>\r\n\t\t<li>The service has its injectable fields populated:\r\n<pre>\r\n\tcontext.injector.injectInto(someService);\r\n</pre>\r\n\t\t</li>\r\n\t\t<li>The service is initialized:\r\n<pre>\r\n\tfeatureSelectionService.init();\r\n</pre>\r\n\t\t</li>\r\n\t</ul>\r\n</p>\r\n\r\n<h1>Utilities</h1>\r\n\r\n<p>\r\nA few \"internals\" that might be useful.\r\n</p>\r\n\r\n<h2>Dictionary</h2>\r\n<p>\r\nEasily map from any kind of object to any other kind of object. The JavaScript Array/Object classes are limited to Numeric/String keys.\r\n</p>\r\n\r\n<p>\r\nThe Dictionary is used heavily throughout the framework. The implementation could be improved performance-wise, but I've left it in a more readable form, during development.\r\n</p>\r\n\r\n<h2>ModelMediator</h2>\r\n<p>\r\n<strong>Note:</strong> This is different from the View Mediator pattern discussed above. \r\n</p>\r\n\r\n<p>\r\nPass a model instance to the constructor function. The object you get back will proxy set/get access on the original model object while providing a change handler for each field in the model. In the default implementation, that's every field accessible by for..in\r\n</p>\r\n\r\n<p>\r\nThe change signals are stored in a Dictionary called __on__\r\n<pre>\r\n\tvar mediator = new ModelMediator(modelInstance);\r\n\tmediator.__on__.someField.add(function () { console.log(\"someField changed!\") })\r\n</pre>\r\n</p>\r\n\r\n</body>\r\n</html>","tagline":"a micro-architecture for JavaScript.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}